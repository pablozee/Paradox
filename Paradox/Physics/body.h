#pragma once

#include "../ParadoxMath.h"

using namespace DirectX;

class RigidBody
{
protected:
	double inverseMass;
	Matrix3 inverseInertiaTensor;
	double linearDamping;
	double angularDamping;
	Vector3 position;
	Quaternion orientation;
	Vector3 velocity;
	Vector3 rotation;
	
	// Derived Data:
	Matrix3 inverseInertiaTensorWorld;
	double motion;
	bool isAwake;
	bool canSleep;
	Matrix4 transformationMatrix;

	// Force and Torque Accumulators:
	Vector3 forceAccum;
	Vector3 torqueAccum;
	Vector3 acceleration;
	Vector3 lastFrameAcceleration;

public:
	void CalculateDerivedData();

	// Integrates the rigidbody forward by the given amount
	// Use a Newton-Euler integration method which is a 
	// linear approximation to the correct integral. (Could be inaccurate in some cases)
	void Integrate(double duration);
	void SetMass(const double mass);
	double GetMass() const;
	void SetInverseMass(const double inverseMass);
	double GetInverseMass() const;
	bool HasFiniteMass() const;

	// Sets inertia tensor which must be a full rank matrix and invertible
	// Invalidates internal data for the rigidbody, must be called 
	// After Integrate or CalculateInternals if trying to get data from the rigidbody
	void SetInertiaTensor(const Matrix3& inertiaTensor);
	
	void GetInertiaTensor(Matrix3* inertiaTensor) const;
	// Returns inertia tensor in RBs' local space
	Matrix3 GetInertiaTensor() const;

	// Copies the current inertia tensor of RB into given matrix
	// Inertia tensor is expressed in world space
	void GetInertiaTensorWorld(Matrix3* inertiaTensor) const;

	Matrix3 GetInertiaTensorWorld() const;

	void SetInverseInertiaTensor(const Matrix3& inverseInertiaTensor);
	void GetInverseInertiaTensor(Matrix3* inverseInertiaTensor) const;
	Matrix3 GetInverseInertiaTensor() const;

	void GetInverseInertiaTensorWorld(Matrix3* inverseInertiaTensor) const;
	Matrix3 GetInverseInertiaTensorWorld() const;

	void SetDamping(const double linearDamping, const double angularDamping);
	
	void SetLinearDamping(const double linearDamping);
	double GetLinearDamping() const;

	void SetAngularDamping(const double angularDamping);
	double GetAngularDamping() const;

	void SetPosition(const Vector3 &position);
	void SetPosition(const double x, const double y, const double z);
	void GetPosition(Vector3* position) const;
	Vector3 GetPosition() const;

	// The given orientation does not have to be normalized and can be zero
	void SetOrientation(const Quaternion& orientation);
	void SetOrientation(const double r, const double i, const double j, const double k);
	void GetOrientation(Quaternion* orientation) const;
	Quaternion GetOrientation() const;

	// Transforming a direction vector by this matrix turns it from
	// transforms it from local space to world space
	void GetOrientation(Matrix3* orientationMatrix) const;
	void GetOrientation(double matrix[9]) const;

	// Transforming a vector by this matrix turns it from
	// transforms it from local space to world space
	void GetTransform(Matrix4* transform) const;
	void GetTransform(double matrix[16]) const;
	Matrix4 GetTransform() const;

	// Converts the given point from world space into bodys' local space
	Vector3 GetPointInLocalSpace(const Vector3& wsPoint) const;

	// Converts the given point from bodys' local space into world space
	Vector3 GetPointInWorldSpace(const Vector3& lsPoint) const;

	// Converts the given direction from world space into bodys' local space
	Vector3 GetDirectionInLocalSpace(const Vector3& wsDirection) const;

	// Converts the given direction from bodys' local space into world space
	Vector3 GetDirectionInWorldSpace(const Vector3& wsDirection) const;

	void SetVelocity(const Vector3& velocity);
	void SetVelocity(const double x, const double y, const double z);

	void GetVelocity(Vector3* velocity) const;
	Vector3 GetVelocity() const;

	void AddVelocity(const Vector3& deltaVelocity);

	void SetRotation(const Vector3& rotation);
	void SetRotation(const double x, const double y, const double z);

	void GetRotation(Vector3* rotation);
	Vector3 GetRotation() const;

	void AddRotation(const Vector3& deltaRotation);

	bool GetAwakeStatus() const
	{
		return isAwake;
	}

	// Sets the awake state of the body
	// If the body is not awake, its' velocities
	// Are also cancelled since a moving body that
	// Is not awake can cause problems in the simulation
	void SetAwakeStatus(const bool awakeStatus = true);

	bool GetCanSleepProperty() const
	{
		return canSleep;
	}

	// Sets CanSleep property.
	// Bodies under the players control or for which
	// transient forces applied each frame are not
	// predictable should be kept awake
	void SetCanSleep(const bool canSleep = true);

	/////////////////////////////////////////////
	// Retrieval functions for Dynamic Quantities
	/////////////////////////////////////////////
	
	// These functions provide access to the acceleration
	// properties of the body
	// The acceleration is generated by the simulation 
	// from the forces and torques applied to the rigidbody.
	// Acceleration cannot be directly influenced in the system.
	// It is set during integration and represents the acceleration
	// Experienced by the body of the previous simulation step

	// Returns current accumulated value for linear accumulation in world space
	// Acceleration accumulators are set during the integration step
	void GetLastFrameAcceleration(Vector3* linearAcceleration) const;
	Vector3 GetLastFrameAcceleration() const;

	/////////////////////////////////////////////
	// Force, Torque and Acceleration set up functions
	/////////////////////////////////////////////

	// Clears forces and torques in the accumulators.
	// Called automatically after each integration step
	void ClearAccumulators();

	// Adds given force to centre of mass of the rigid body.
	// The force is expressed in world coordinates
	void AddForce(const Vector3& force);

	// Adds given force to given point on the rigid body.
	// The force and point are both expressed in world coordinates
	// Because the force is not applied to the centre of mass, 
	// It may be split into a force and a torque
	void AddForceAtPoint(const Vector3& force, const Vector3& point);

	// Adds given force to given point on the rigid body.
	// The direction of the force is expressed in world coordinates
	// The application point is expressed in body local coordinates
	// This is useful for spring forces, or other forces fixed to the body
	void AddForceAtBodyPoint(const Vector3& force, const Vector3& point);

	// Adds given torque expressed in world coordinates
	void AddTorque(const Vector3& torque);

	// Sets the constant acceleration of the rigid body.
	void SetAcceleration(const Vector3& acceleration);
	void SetAcceleration(const double x, const double y, const double z);

	void GetAcceleration(Vector3* acceleration) const;
	Vector3 GetAcceleration() const;
};